# 类在什么时候加载和初始化

​	理解类在JVM中什么时候被加载和初始化是Java编程语言中的基础概念，正因为有了Java语言规范，我们才可以清晰的记录和解释这个问题**，但是很多Java程序员仍然不知道什么时候类被加载，什么时候类被初始化**，类加载和初始化好像让人很困惑，对初学者难以理解，在这篇教程中我们将看看类加载什么时候发生，类和接口是如何被初始化的，我并不会拘泥于类加载器的细节或者说类加载器的工作方式。仅仅使这篇文章更加专注和简结

#### 一个java文件从被加载到被卸载这个生命过程

总共要经历5个阶段，JVM将类加载过程分为：

**加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载** 

### 一、类的加载

#### 1.1类什么时候加载？

​	所有的类都是在对其第一次使用时候,**动态加载到JVM中的**。**==当程序创建第一个对类的静态成员引用时==**,就会加载这个类。类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。不过我相信这跟不同的JVM实现有关，然而他又是受JLS保证的（**当有==静态初始化需求==的时候才被加载**）。最后在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。

#### 1.2类加载做的事情

​	类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，**然后在堆区创建一个这个类的java.lang.Class对象**，用来封装类在方法区类的对象。如： 

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180512/a1abKmejak.png?imageslim)

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180512/am802L0i3a.png?imageslim)

#### 1.3类加载最终结果

类的加载的最终产品是位于堆区中的Class对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。加载类的方式有以下几种： 
　　1）从本地系统直接加载 
　　2）通过网络下载.class文件 
　　3）从zip，jar等归档文件中加载.class文件 
　　4）从专有数据库中提取.class文件 
　　5）将Java源文件动态编译为.class文件（服务器）

#### 1.4加载器

JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180512/HL02d2jj69.png?imageslim)

加载器介绍 
1）BootstrapClassLoader（启动类加载器） 
　　负责加载`$JAVA_HOME中jre/lib/rt.jar`里所有的class，加载System.getProperty(“sun.boot.class.path”)所指定的路径或jar。 
2）ExtensionClassLoader（标准扩展类加载器） 
　　负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。载System.getProperty(“java.ext.dirs”)所指定的路径或jar。 
3）AppClassLoader（系统类加载器） 
　　负责记载classpath中指定的jar包及目录中class 
4）CustomClassLoader（自定义加载器） 
　　属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。

（2）类加载器的顺序 
1）加载过程中会先检查类是否被已加载，**检查顺序是自底向上**，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而**加载的顺序是自顶向下**，也就是由上层来逐层尝试加载此类。 
2）在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。 
3）Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null。

###二、链接： 

　　验证：确保被加载类的正确性； 
　　准备：**为类的静态变量分配内存，并将其初始化为默认值**； 
　　解析：把类中的符号引用转换为直接引用； 

#### 类什么时候初始化

加载完类后，类的初始化就会发生，意味着它会初始化所有类静态成员，以下情况一个类被初始化：

1. 实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。
2. 类的静态方法被调用
3. 类的静态域被赋值
4. 静态域被访问，而且它不是常量（final）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. 在顶层类中执行assert语句

反射同样可以使类初始化，比如java.lang.reflect包下面的某些方法，JLS严格的说明：一个类不会被任何除以上之外的原因初始化。

#### 类是如何被初始化的

现在我们知道什么时候触发类的初始化了，他精确地写在Java语言规范中。但了解清楚 域（fields，静态的还是非静态的）、块（block静态的还是非静态的）、不同类（子类和超类）和不同的接口（子接口，实现类和超接口）的初始化顺序也很重要类。事实上很多核心Java面试题和SCJP问题都是基于这些概念，下面是类初始化的一些规则：

​	1）如果这个类还没有被加载和链接，那先进行加载和链接 
　　2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 
　　3）加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 
　　4）总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法 

