# java自动类型转换

java转型范围，自动转型和强制转型

## 1.自动类型转换

- 也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM 自动完成。

- 转换规则：从存储范围小的类型到存储范围大的类型。

  具体规则为：byte→short(char)→int→long→float→double

  注意问题:在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是==比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失==。

- 窄化（向下转型）和宽化转换

  基本类型转型（除boolean，这个不能接受任何转型动作） 只要是宽化转换，就不需要明确指示。因为新型别能容纳来自是旧型别的信息，而不会遗失任何信息。只要有窄化转换时，编译器才会要求你强制转型

  ```java
  short s = 2；
  不会丢失精度，所以不提示失败，如果
  short s = 222222;
  就会提示失败，需要你进行强制转型;因为short的最大的数值是32767

  1、float f=3.4;是否正确？ 
  答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F .

  注：由上面想到： byte、short 、 int 、 long 在初始化的时候给予整数，如long l = 3; byte b = 3; 虽然3默认是int类型的，但是这样是正确的。 这里需要在双精度数字后面加字母的只有float这一例了

  2、short s1 = 1; s1 = s1 +1;有错吗?short s1 = 1; s1 += 1;有错吗？ 
  答：short s1 = 1; s1 = s1 + 1是错的，s1 + 1在运算过程中1是int类型，s1是short类型，向高的转，结果为int类型，所以这里需要强转，而 s1 += 1是正确的，因为jvm自动帮我们处理好了

  注：short s1 = 1 + 2 + 3;是正确的。当然除了short 比short低的byte也有同样的问题
  ```

## 2.强制类型转换

- 也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。

  转换规则:从存储范围大的类型到存储范围小的类型。

  具体规则为：double→float→long→int→short(char)→byte

  语法格式为：(转换到的类型)需要转换的值