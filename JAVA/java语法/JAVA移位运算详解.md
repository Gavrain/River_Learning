# JAVA移位运算详解

java移位运算符不外乎就这三种：<<（左移）、>>（带符号右移）和>>>（无符号右移）。 

## **1、 左移运算符** 

左移运算符<<使指定值的所有位都左移规定的次数。 

1）它的通用格式如下所示： 
value << num 
num 指定要移位值value 移动的位数。 
左移的规则只记住一点：丢弃最高位，0补最低位 
如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动33位，实际上只移动了33%32=1位。 



2）运算规则 
按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。 
当左移的运算数是int 类型时，每移动1位它的第31位就要被移出并且丢弃（其中的最高位32位是符号位）； 
当左移的运算数是long 类型时，每移动1位它的第63位就要被移出并且丢弃。 
当左移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。 



3）数学意义 
在数字没有溢出的前提下，==对于正数和负数==，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方 

```java
public class Literal {
    public static void main(String[] args) {
        int num=-3;//11111111111111111111111111111101
        info(num);
        num=num <<2;
        info(num);//-12   11111111111111111111111111110100
    }

    public static  void info(int num){
        System.out.println(Integer.toBinaryString(num));
    }
}
```

4）计算过程： 
例如：3 <<2(3为int型) 
1）把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011， 
2）把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位， 
3）在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100， 
转换为十进制是12。 
移动的位数超过了该类型的最大位数， 
如果移进高阶位（31或63位），那么该值将变为负值。下面的程序说明了这一点： 

```java
// Left shifting as a quick way to multiply by 2.  
public class MultByTwo {  
public static void main(String args[]) {  
   int i;  
   int num = 0xFFFFFFE;   
   for(i=0; i<4; i++) {  
       num = num << 1;   
     System.out.println(num);  
   }  
  }  
} 
```

该程序的输出如下所示： 

536870908       00011111111111111111111111111100
1073741816     00111111111111111111111111111000     
2147483632     01111111111111111111111111110000      
-32 
注：n位二进制，最高位为符号位，因此表示的数值范围-2^(n-1) ——2^(n-1) -1,所以模为2^(n-1)。



## 2、 右移运算符 

右移运算符<<使指定值的所有位都右移规定的次数。 
1）它的通用格式如下所示： 
value >> num 
num 指定要移位值value 移动的位数。 
右移的规则只记住一点：符号位不变，左边补上符号位 

2）运算规则： 
按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1 
当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。 
例如，如果要移走的值为负数，每一次右移都在左边补1，如果要移走的值为正数，每一次右移都在左边补0，这叫做符号位扩展（保留符号位）（sign extension ），在进行右移 

操作时用来保持负数的符号。 


3）数学意义 
右移一位相当于除2，右移n位相当于除以2的n次方。 

4）计算过程 
11 >>2(11为int型) 
1)11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011 
2)把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。 
3)最终结果是0000 0000 0000 0000 0000 0000 0000 0010。 
转换为十进制是3。 

35 >> 2(35为int型) 
35转换为二进制：0000 0000 0000 0000 0000 0000 0010 0011  
把低位的最后两个数字移出：0000 0000 0000 0000 0000 0000 0000 1000 
转换为十进制： 8 

```java
public class Literal {
    public static void main(String[] args) {
        int num=35;
        info(num);
        num=num >>2;
        info(num);
    }

    public static  void info(int num){
        System.out.println(Integer.toBinaryString(num));
    }
}
```

5）在右移时不保留符号的出来 
右移后的值与0x0f进行按位与运算，这样可以舍弃任何的符号位扩展，以便得到的值可以作为定义数组的下标，从而得到对应数组元素代表的十六进制字符。 



### 3**、无符号右移** 

无符号右移运算符>>> 
它的通用格式如下所示： 
value >>> num 
num 指定要移位值value 移动的位数。 
无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位 
无符号右移运算符>>> 只是对32位和64位的值有意义