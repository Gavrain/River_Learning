## Synchronized详解

[TOC]



## 概述

在多线程编程中，线程安全问题是一个最为关键的问题，其核心概念就在于正确性，即当多个线程访问某一共享、可变数据时，始终都不会导致数据破坏以及其他不该出现的结果。而所有的并发模式在解决这个问题时，采用的方案都是序列化访问临界资源 。在 Java 中，提供了两种方式来实现同步互斥访问：synchronized 和 Lock。本文针对 synchronized 内置锁 详细讨论了其在 Java 并发 中的应用，包括它的具体使用场景（同步方法、同步代码块、实例对象锁 和 Class 对象锁）、可重入性 和 注意事项。 

## 一、内置锁

多线程编程中，当代码需要同步时我们会用到锁。Java为我们提供了**内置锁(synchronized)和显式锁**(ReentrantLock)两种同步方式 ；**java中每一个对象可以被用作同步的锁，这些对象就是内置锁**；

内置锁使用起来非常方便，不需要显式的获取和释放，任何一个对象都能作为一把内置锁。使用内置锁能够解决大部分的同步场景。“任何一个对象都能作为一把内置锁”也意味着出现synchronized关键字的地方，都有一个对象与之关联，具体说来：

当synchronized作用于普通方法是，锁对象是this(当前类的实例)；

当synchronized作用于静态方法是，锁对象是当前类的Class对象；

当synchronized作用于代码块时，锁对象是synchronized(obj)中的这个obj。

## 二、synchronized 同步方法或者同步块

　　**互斥锁**，即 **能到达到互斥访问目的的锁。**举个简单的例子，如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。

　　在 Java 中，可以使用 synchronized 关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。

不过需要注意以下三点：

　　1）**当一个线程正在访问一个对象的 synchronized 方法，那么其他线程不能访问该对象的其他 synchronized 方法。**这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。

　　2）**当一个线程正在访问一个对象的 synchronized 方法，那么其他线程能访问该对象的非 synchronized 方法。**这个原因很简单，访问非 synchronized 方法不需要获得该对象的锁，假如一个方法没用 synchronized 关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，

　　3）**如果一个线程 A 需要访问对象 object1 的 synchronized 方法 fun1，另外一个线程 B 需要访问对象 object2 的 synchronized 方法 fun1，即使 object1 和 object2 是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。**

## 三、Synchronized的JVM层面原理

Synchronized是基于monitorenter和monitorexit

```java
public int moniter(){
        synchronized (Sequence.class) {
            if (value > 0) {
                return value;
            } else {
                return -1;
            }
        }
    }
```

下面是这个方法的字节码指令

```xml
 0 ldc #3 <com/huanghe/Thread1/Sequence>
 2 dup
 3 astore_1
 4 monitorenter
 5 aload_0
 6 getfield #2 <com/huanghe/Thread1/Sequence.value>
 9 ifle 19 (+10)
12 aload_0
13 getfield #2 <com/huanghe/Thread1/Sequence.value>
16 aload_1
17 monitorexit
18 ireturn
19 iconst_m1
20 aload_1
21 monitorexit
22 ireturn
23 astore_2
24 aload_1
25 monitorexit
26 aload_2
27 athrow
```

下面查看一下同步方法：

```java
 public synchronized int getNext() {
        return value++;
    }
```

字节码文件：

```xml
0 aload_0
1 dup
2 getfield #2 <com/huanghe/Thread1/Sequence.value>
5 dup_x1
6 iconst_1
7 iadd
8 putfield #2 <com/huanghe/Thread1/Sequence.value>
11 ireturn

```

可以看到在同步方法里面是没有monitorenter和monitorexit的

## 四、锁信息又存在对象的什么地方

任何对象都可以作为锁，锁信息又存在对象的什么地方呢？

> 对象头中；HotSpot中对象在内存中的布局分为三部分的信息，对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）;对象头包括两部分信息，第一部分是用于存储对象自身的运行时的数据（Mark Word），如哈希码、GC分代年龄、**锁状态标志**、线程持有锁、偏向线程ID等。第二部分是类型指针(Class MeteData Address)，即对象指向它的类元数据的指针

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180717/2dB1le898a.png?imageslim)



## 五：锁优化

**线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。**

Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。

**锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。**

### 5.1、偏向锁

Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个**线程锁重入（CAS）的开销**，看起来让这个线程得到了偏护。 

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180717/HE8d725c6F.png?imageslim)



**偏向锁的获取：**

1：首先会检查锁（对象）标志位是否为01（是否为偏向锁）

2：紧接着会检查锁中的线程ID是否和当前的线程的ID一致，如果一致，那么就不需要获取锁，直接的进入到同步代码块（就不存在锁的获取和释放过程了）

3：如果是锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。

4：接下来会使用CAS操作把获取到的这个锁的线程的ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步代码块的时候，虚拟机都可以不再进行任何的同步操作；如果不成功撤销偏向锁，同时会暂停持有偏向锁的线程，持有偏向锁的线程才会去释放偏向锁恢复到未锁定状态；

**偏向锁的撤销：**

偏向锁使用了一种等到竞争才会出现释放锁的机制，所以当其他的线程尝试竞争偏向锁的时候，持有偏向锁的线程才会去释放偏向锁恢复到未锁定状态（标志位为“01”）或轻量级锁定（“00”）的状态；

**偏向锁的适用的场景：**

只有一个线程访问同步代码块的时候，会大大的提高它的性能，因为不需要每次去执行获取和释放锁的过程；减少了资源的消耗；

**偏向锁的缺点：**

当有多个线程对同一代码块进行访问，此时的情形下是并不会提高它的性能的

### 5.2、轻量级锁

### 轻量级锁加锁

线程在执行同步块之前，如果此同步对象没有被锁定(锁的标志位为“01”状态)，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（Lock Record），用于存储锁对象目前的MarkWord拷贝（官方把这个拷贝加了一个Dispatcher前缀，即Dispatcher Mark World）。**然后虚拟机尝试使用CAS将对象头中的Mark Word替换为指向锁记录空间的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。**

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180717/Hi2IKcAkEI.png?imageslim)

**加锁的执行过程**：

1：线程在执行同步块之前，如果此同步对象没有被锁定(锁的标志位为“01”状态)

2：JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（Lock Record），用于存储锁对象目前的MarkWord拷贝（Dispatcher Mark Word）

3：虚拟机尝试使用CAS将对象头中的Mark Word替换为指向锁记录空间的指针

4：然后开始竞争锁，当竞争成功之后，锁标志位改为轻量级锁（“00”），开始执行同步体；竞争失败的线程也准备去修改Mark Word，但是它发现线程的锁已经被别的线程获取到了，所以它修改不成功，然后失败的线程会进行自旋锁的操作，如果仍然失败的话，那么就膨胀为重量级锁，锁的标志位改为（“10”），线程会阻塞；

5：当第一个线程执行完毕释放锁并且唤醒第二个线程，

**释放锁的执行过程：**

1：如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS的操作把对象的Mark Word和操作数栈中复制的Dispatcher Mark Word 替换回来，如果替换成功，整个的同步过程就完成

2：如果替换失败，说明有其他线程尝试获取过该锁，那就需要在释放锁的同时，唤醒被挂起的线程

### 轻量级锁解锁

**轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。**如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。下图是两个线程同时争夺锁，导致锁膨胀的流程图。

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180717/9mekH4lBie.png?imageslim)



## 六、锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                           | 适用场景                         |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | -------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程使用自旋会消耗CPU    | 追求响应时间,锁占用时间很短      |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量,锁占用时间较长        |

## 七. Synchronized总结

　　用一句话来说，**synchronized 内置锁 是一种 对象锁 (锁的是对象而非引用)， 作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是 可重入 的。**特别地，对于 **临界资源** 有：

- **若该资源是静态的，即被 static 关键字修饰，那么访问它的方法必须是同步且是静态的，synchronized 块必须是 class锁；**
- **若该资源是非静态的，即没有被 static 关键字修饰，那么访问它的方法必须是同步的，synchronized 块是实例对象锁；** 

**实质上，关键字synchronized 主要包含两个特征：**

- **互斥性：**保证在同一时刻，只有一个线程可以执行某一个方法或某一个代码块；
- **可见性：**保证线程工作内存中的变量与公共内存中的变量同步，使多线程读取共享变量时可以获得最新值的使用