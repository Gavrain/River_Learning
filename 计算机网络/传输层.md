# 传输层

[TOC]



![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180901/3596ic0FfF.png?imageslim)



##传输层和应用层的关系

TCP协议或者是UDP协议加上端口就是应用层协议

1). TCP对应的**应用层**协议

**FTP**：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。

**Telnet**：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。

**SMTP**：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。

**POP3**：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。

**HTTP**：从Web服务器传输超文本到本地浏览器的传送协议，TCP+80端口。

**HTTPS:**TCP+443端口

**SQL**:TCP+1433端口

**RDP**：远程连接的 TCP+3389

2). UDP对应的应用层协议

**DNS**：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。

**SNMP**：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

**TFTP**(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务

可以使用netstat -n可以查看连接，netstat -nb可以查看进程

## 服务和应用层之间的关系

服务使用TCP或者是UDP的端口侦听客户端的请求

客户端使用IP地址定位服务器，使用目标端口定位服务

可以在服务器网卡上设置只开放必要的端口 实现服务器的安全

## 如何查看服务侦听的端口

查看的命令就是`netstat -an`

查看建立的会话`netstat -n`

查看建立会话的连接  `netstat -nb`

测试到远程计算机的某个端口是否打开了 `telnet 192.168.80.100 3389`

## 网络层和传输层的区别

网络层负责ip数据报的产生以及ip数据包在逻辑网络上的路由转发 ，提供的是主机之间的逻辑通信

传输层提供端到端通信服务层次,提供可靠及非可靠连接 ，提供的是进程之间的逻辑通信

网络层只是根据网络地址将源结点发出的数据包传送到目的结点（点到点），其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。 

而传输层则负责将数据可靠地传送到相应的端口（端到端），传输层提供了主机应用程序进程之间的端到端的服务。传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使高层用户看到的只是在两个传输实体间的一条端到端的、可由用户控制和设定的、可靠的数据通路。 

##**传输层的端口**

![1535855458539](../../../../AppData/Local/Temp/1535855458539.png)

网络层区别是TCP还是UDP协议使用的是**协议号**：TCP的协议号是6 UDP的协议号是17  IGMP 1

传输层是怎么区分它的上层应用的？    使用的是**端口号**

端口是用一个16位的二进制进行标志的

**端口号具有本地的意义**，即端口号只是为了标志本计算机应用层中的各个进程。在英特网中不同计算机的相同的端口号是没有联系的

## UDP

- UDP是无连接的，即发送数据之前是不需要建立连接的
- UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制
- UDP是面向报文的。UDP没有拥塞机制，适合多媒体通信要求
- UDP支持一对一，一对多，多对多的交互通信
- UDP的首部开销小，只有8个字节

![1535856465020](../../../../AppData/Local/Temp/1535856465020.png)

UDP首部：

![1535856491161](../../../../AppData/Local/Temp/1535856491161.png)

UDP的长度：指的就是UDP的首部加上数据的长度

检验和：伪首部（12个字节）+UDP的首部+数据 （在传输层的检验和是需要网络层的首部的部分信息）

计算UDP的检验和的例子如下：

![1535856918670](../../../../AppData/Local/Temp/1535856918670.png)

## TCP

- TCP是面向连接的
- TCP是一对一的传输
- TCP提供可靠的交付服务
- TCP是面向字节流的
- TCP提供全双工通信

有的数据在网上进行传输的时候不可能一个数据包就能全部的传输完成，这就要求数据包进行分段的传输，分成了多个段之后，一个段就是一个数据包。这个时候网络有可能不稳定，处理不过来，数据包出现丢失，也就是网络层是不负责可靠的传输的，这个时候需要传输层TCP实现可靠的传输；

比如说，客户端收数据慢，服务端发数据快，客户端就把部分的数据包给扔掉了，这个时候TCP协议需要实现流量的控制功能

还有可能是网络是非常的堵，出现丢包的现象，TCP需要实现网络拥塞避免



## TCP的可靠传输

可靠传输的工作原理---停止等待协议

![1535858958893](../../../../AppData/Local/Temp/1535858958893.png)

确认丢失和确认迟到的情况

![1535858997641](../../../../AppData/Local/Temp/1535858997641.png)

先看确认丢失：

- A->B发送数据包，B收到数据包，要返回一个确认，但是这个确认丢失了，A经过一个RTT的时间之后，还没有收到B发过来的确认信号，所以A会继续的发送前面的一个M1数据包给B
- 此时B收到了两个相同的数据包M1,丢弃一个M1,发送确认的数据包给A

确认迟到：

- A->B 发送一个数据包，但是B可能回复确认的信号的时间比较长。A没有收到确认信息，A会继续的发送确认的信号给B,此时B收到两个相同的数据包M1,B就会丢弃其中的一个数据包，并且把其中的一，并且把确认的数据包发送到A端
- A过了一段时间收到了B的延迟的确认包，这时A收到之后什么都不会做

**总结**

> 使用上述的确认和重传的机制，我们就可以在不可靠的网络上实现可靠的通信
>
> 这种可靠的传输协议常称是**自动重传请求ARQ**

**停止等待协议**的有点是简单，缺点是信道利用率太低了

![1535859718221](../../../../AppData/Local/Temp/1535859718221.png)

发数据包的时间是TD，但是大部分的时间是在等待的

$U=\frac{T_D}{T_D+RTT+T_A}$

要使得信道利用率增加需要使得$T_D$增加，在实际的操作中就是**发送方连续的发送多组数据，不必发完一个分组就停顿下来等待对方确认**

![1535860128786](../../../../AppData/Local/Temp/1535860128786.png)

使用的就是**流水线程传输**

流水线传输的可靠性是如何做到的呢？连续的ARQ协议

![1535860322798](../../../../AppData/Local/Temp/1535860322798.png)



**总结TCP的可靠传输的保证：**



### TCP的首部标记技术

![1535874133621](../../../../AppData/Local/Temp/1535874133621.png)



序号：TCP是面向字节流进行传输的，数据是分块在TCP缓存里面进行存放的，TCP需要组建数据包一段一段的向外发送，数据包向外发送的时候需要加上头，头也是需要加上序号的，这个需要是怎么确定的呢？

就是这个数据段的第一个字节是整个数据的第几个字节

确认号：32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应 当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字 段才有效 

![1535878256850](../../../../AppData/Local/Temp/1535878256850.png)

URG: 1代表的是插队，优先级别比较高，优先进行传输

ACK:确认序号

PUSH：1代表的是优先级比较高，所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序， 而不是在缓冲区中排队; 

RST:1说明TCP会话出现严重的错误，需要重新的建立连接

数据偏移：数据开始的位置，TCP的最大的数据是60个字节

![1535878833229](../../../../AppData/Local/Temp/1535878833229.png)

窗口：在A和B之间进行相互的通信的时候，需要相互的进行协商各自的窗口的大小（也就是缓存的大小），根据对方的接收窗口的大小来设置发送窗口的大小

校验和：首部和数据 （需要加上伪首部）

紧急指针：在URG为1的时候，紧急指针才会起作用

## TCP的滑动窗口的技术的可靠传输

![1535881053846](../../../../AppData/Local/Temp/1535881053846.png)

1. 首先是123 和456和78910构成数据包在网上进行传输，B的接收窗口接收到A发送过来的数据包之后给一个确认确认号7给A,此时的情形就如上图中所示
2. A中的窗口可以滑动到7的位置，继续的向B传输数据包，此时B继续的进行接收A传输过来的数据包

**现在分析假如在传输的过程中出现丢失，TCP是如何保证可靠传输的**：

![1535881689881](../../../../AppData/Local/Temp/1535881689881.png)

1. 假如123构成数据包在网上传，456构成数据包在网上传，789构成数据包在网上进行传输 10,11,12构成数据包，假如说现在在传输的过程中789数据包出现了丢失；
2. B收到了123数据包和456数据包，但是接下来收到的是10,11,12数据包，此时的B发给A的确认号是7，并且还有一个标志是SACK告诉A哪些数据包丢失了
3. 这个时候A只发丢失的数据包，不会再发10,11,12数据包了

## TCP协议如何实现流量控制

![1535883143094](../../../../AppData/Local/Temp/1535883143094.png)

不断的去改变滑动窗口的大小，假如说B再次的需要重新的设置窗口的大小为10 的话，这个时候

## TCP的拥塞控制

出现资源拥塞的条件：对资源需要的总和 > 可用的资源 

拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器

拥塞避免是说在拥塞避免阶段把拥塞窗口控制为按照线性的增长，使网络比较不容易出现拥塞

**拥塞控制的作用：**

![1535890809867](../../../../AppData/Local/Temp/1535890809867.png)

**慢开始算法和拥塞避免**算法

发送方维持拥塞窗口cwnd

发送方拥塞控制窗口的原则是：

- 只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去
- 只要网络出现拥塞，拥塞i窗口就会减小一些，以减少注入到网络中的分组数

![1535892274545](../../../../AppData/Local/Temp/1535892274545.png)

![1535892396234](../../../../AppData/Local/Temp/1535892396234.png)

开始出现网络拥塞时 ：新的慢开始门限为拥塞窗口值的1/2，拥塞窗口又开始从1开始慢慢的增长，开始的时候是呈现指数形式的增加，当到达了慢开始门限之后就开始线程增长

**快重传算法和快恢复算法**（相对于慢开始来说比较快）

拥塞窗不再从1开始，而是直接的从新的慢开始门限开始，以线性的速度进行增加

发送窗口的实际值：为接收方窗口和拥塞i窗口这两个变量中较小的一个

## TCP的三次握手

![1535894547507](../../../../AppData/Local/Temp/1535894547507.png)

![1535895927196](../../../../AppData/Local/Temp/1535895927196.png)

