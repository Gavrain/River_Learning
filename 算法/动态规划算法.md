# 贪心算法与动态规划

[TOC]



贪心算法：是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

动态规划算法：当中包含三个重要的概览“最优子结构”、“边界”、“转态转移方程”

### 爬楼梯问题

 **[问题描述]**：

一个人每次只能走一层楼梯或者两层楼梯，问走到第80层楼梯一共有多少种方法。 

$F(1) =1  $ 边界

$F(2)=1$  边界

$F(n)=F(n-1)+F(n-2) (n>=3)$ 最优子结构

代码就不写了就是斐波拉契数列的实现代码

**[思想]：**

自顶向下做递归运算转化为自底向上做迭代运算

- 第一行代表的是台阶的数目，第二行数若干台阶需要的走法数。F(1)=1,F(2)=2,这是之前就确定了的问题
- 第一次的迭代，台阶数为3时，走法数量是3.这个结果是F(1)+F(2) = 3
- 第二次的迭代，台阶数目为4，F(4)= F(3)+F(2);
- 同理，在后续的迭代过程中，F(5) =F(4)+F(3);

| 台阶数 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 走法数 | 1    | 2    | 3    | 5    | 8    |      |      |      |      |
|        |      |      |      |      |      |      |      |      |      |
|        |      |      |      |      |      |      |      |      |      |
|        |      |      |      |      |      |      |      |      |      |
|        |      |      |      |      |      |      |      |      |      |
|        |      |      |      |      |      |      |      |      |      |

### 国王和金矿

**[问题描述]**：

有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180820/97Iagdmff3.png?imageslim)

**[思路]：**

```
如果选择的是不挖，那么最优子结构是10个工人挖4个金矿时挖出的黄金最多的
如果选择的是挖，那么就是会占用一部分的工人数量，那么前4个金矿所分配的工人数量就是[10-第5个金矿所需要的人数]，而不再是10了
所以说最优的子结构有两种：1、4个金矿10个工人时的最优选择 2、4个金矿10-3 = 7个工人时的最优选择
```

为了描述为了便于描述，我们把金矿数量设为N,工人数目设为W,金矿的黄金量设为G[] ,金矿的用工人的数量记为P[];

那么5座金矿和4做金矿的最优选择之间的关系是 F(5,10) = MAX{ F(4,10) ,F(4,10)+G[4])；

最后需要确定边界：

1、如果只有1座金矿，也就是N=1的时候。这个时候就是没得选择，得到的黄金数量是G[0]

2、如果给的工人数不够挖第一个金矿，也就是W<P[0]，得到的黄金数量是G[0]

3、N =1  w>P[0]   F(N,W)=G(0)

4、N=1  W<P[0]  F(N,W) =0;

所以最后的状态转移方程

$F(n,w) = 0 (n<=1,w<p[0])$

$F(n,w) = G[0] (n=1,w>p[0])$

$F(n,w) = F(n-1,w) (n>1,w<p[n-1])$

$F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1])+g[n-1]) (n>1, w>=p[n-1]) $

题目描述：

1金矿：400金 ，5工人

|       | 1工人 | 2工人 | 3工人 | 4工人 | 5工人 | 6工人 | 7工人 | 8工人 | 9工人 | 10工人 |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ------ |
| 1金矿 | 0     | 0     | 0     | 0     | 400   | 400   | 400   | 400   | 400   | 400    |
| 2金矿 | 0     | 0     | 0     | 0     | 500   | 500   | 500   | 500   | 500   | 900    |
| 3金矿 | 0     | 0     | 200   | 200   | 500   | 500   | 500   | 700   | 700   | 900    |
| 4金矿 | 0     | 0     | 200   | 300   | 500   | 500   | 500   | 700   | 800   | 900    |
| 5金矿 | 0     | 0     | 200   | 300   | 500   | 500   | 500   | 850   | 800   | 900    |

- 1金矿：400金 ，5工人，所以前4个格子都是0，因为人数不够。后面的格子都是400，因为只有这一个金矿
- 2金矿：500金，5工人，前4个格子$W<5$ 所以F(N,W) = F(N-1,W)=0,后面的6个格子是 $w>=5 F(N) =Max(F(N-1,W),F(N-1,W-5)+500) $,第5-9个格子数500
- 3金矿：200金，3个工人
- 4金矿：300金，4个工人
- 5金矿：350金，3工人

**[规律]：**

除了第一行外，每个格子都是由前一行的一个或者是两个格子推导得到的，比如说第3行的第8个格式

$F(3,8) =Max(F(2,8),F(2,5)+G[3])$

$F(3,8) = Max(500,500+200)$

```java
public class KingAndGold {

    public static void main(String[] args) {
        int n = 5;
        int w = 10;
        int[] g = {400, 500, 200, 300, 450};
        int[] p = {5, 5, 3, 4, 3};
        int mostGold = getMostGold(n, w, g, p);
        System.out.println(mostGold);

    }

    /**
     * @param n：总金矿的数目
     * @param w：总的工人数目设为W,
     * @param g：金矿的黄金量设为G[]
     * @param p：每一个金矿的需要的工人数量记为P[];
     * @return
     * 动态规划的思想的时间复杂度是O(n*w),空间复杂度是O(w)
     *
     * 简单的递归是O(2^n),空间复杂度是O(n)
     */
    public static int getMostGold(int n, int w, int[] g, int[] p) {
        int[] preResults = new int[w+1];
        int[] results = new int[w+1];

        //填充边界的格子
        for (int i = 1; i <=w; i++) {
            if (i < p[0]) {
                preResults[i] = 0;
            } else {
                preResults[i] = g[0];
            }
        }

        //填充其余的格子的值,
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= w; j++) {
                if (j < p[i-1]) {
                    results[j] = preResults[j];
                } else {
                    //F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1])+g[n-1])
                    results[j] = Math.max(preResults[j], preResults[j - p[i-1]] + g[i-1]);
                }
            }
            System.arraycopy(results, 0, preResults, 0, w+1);
        }
        return results[w];
    }
}

```

### 钢条切割问题

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180820/95fDCJ3438.png?imageslim)

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180820/kljhk0IEFD.png?imageslim)

更加一般的情况是，对于$r_n(n>=1)$,我们可以用更短的钢条的最优切割收益来描述它：

$r_n = max(P_n,r_1+r_{n-1},r_2+r_{n-2},...+r_{n-1}+r_1）$

$P_n$:表示的是不切割，直接出售长度为n英寸钢条方案：

$r_1+r_{n-1}$:表示的是将其中的一段切割为1英寸，其他的是在长度为n-1英寸中寻求最大的收益

$r_2+r_{n-2}$:表示的是将其中切一段为2英寸，其他的是在长度为n-2英寸中寻求最大的收益

$r_{n-1}+r_1$:表示的是将其中一段切为n-1英寸的收益，其余的一段为1英寸的收益

最后的问题的总结就是：求解$r_i+r_{n-i}$收益最大的一段

下面我们仍然是画一个表格

|         | 1英寸 | 2    | 3    | 4    |
| ------- | ----- | ---- | ---- | ---- |
| 长度为1 | 1     | 2    | 3    | 4    |
| 长度为2 | 1     | 5    | 6    | 10   |
| 长度为3 | 1     | 5    | 8    | 10   |
| 长度为4 | 1     | 5    | 8    | 10   |
|         |       |      |      |      |

```java
public static int buttom_up_cut(int []p)
    {
        int []r=new int[p.length+1];
        for(int i=1;i<=p.length;i++)
        {
            int q=-1;
            //①
            for(int j=1;j<=i;j++)
                q=Math.max(q, p[j-1]+r[i-j]);
            r[i]=q;
        }
        return r[p.length];
    }
```

这里外面的循环是求r[1],r[2]……，里面的循环是求出r[1],r[2]……的最优解，也就是说r[i]中保存的是钢条长度为i时划分的最优解，这里面涉及到了最优子结构问题，也就是一个问题取最优解的时候，它的子问题也一定要取得最优解。下面是长度为4的钢条划分的结构图。

除了用动态规划的方法还可以使用递归的版本进行解决的：将长度为n的钢条分解为左边开始一段，以及剩余的部分继续分解结果。这样，不做任何切割的方案就可以描述为：第一段的长度为n,收益为$P_n​$,剩余部分的为长度为0，相应的收益$r_0=0​$,于是我们可以得到如下的公式：

$ r_n=max_{1\leq i\leq n }(p_i+r_{n-i})$

```java
public static cut(int[] p,int n){
    if(n==0){
        return 0;
    }
    int q=Integer.MIN_VALUE;
    for(int i=1;i<=n;i++){
        q=Math.max(q,p[i-1]+cut(p,n-i))
    }
    return q;
}
```

### 剪绳子问题

给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n>1并且m>1)每段绳子的长度记为k[0],k[1],…,k[m].请问`k[0]*k[1]*…*k[m]`可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18. 

最优子结构是：F(n) = max( F(i)*F(n-i) ) 其中i的范围是  1<=i<n

**[说明]：**

- 当i=1的时候，就是其中的一段剪为1，其余的为F(n-1)的最优解
- 当i=n-1的时候，就是剪一段n-1长度的，求F(n-1)的最大值

可以利用递归就行求解：

```java
public static int maxProductAfterCutting(int len){
		if(len<2)
			return 0;
		if(len==2)
			return 1;
		if(len==3)
			return 2;
		//存储长度从 0-len 的最大结果
		int[] result=new int[len+1];
		result[0]=0;
		result[1]=1;
		result[2]=2;
		result[3]=3;
		
		//自底向上开始求解
		int max=0;
		for(int i=4;i<=len;i++){
			max=0;
			for(int j=1;j<=i/2;j++){
				int tempResult=result[j]*result[i-j];
				if(max<tempResult)
					max=tempResult;
				result[i]=max;
			}
		}
		max=result[len];
		return max;
	}
```

### 凑面额-问题


**[问题描述]**：

如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ 

思考：

> 我们凭直观感觉告诉自己，先选面值最大，因此最多选 2枚 5 元的硬币，现在是 10 元了，还差一元，接下来我们挑选第二大的 3 元硬币，发现不行（ 10+3=13 超了），因此我们继续选第三大的硬币也就是 1 元硬币，选一个就可以（ 10+1=11 ），所以总共用了 3 枚硬币凑够了 11 元。这就是贪心法，每次选最大的。但是我们将面值改为 2 元， 3 元和 5 元的硬币，再用贪心法就不行了。为什么呢？按照贪心思路，我们同样先取 2 枚最大 5 元硬币，现在 10 元了，还差一元，接下来选第二大的，发现不行，再选第三大的，还是不行，这时用贪心方法永远凑不出 11 元，但是你仔细看看，其实我们可以凑出 11 元的， 2 枚 3 元硬币和 1 枚五元硬币就行了，这是人经过思考判断出来了的，但是怎么让计算机算出来呢？这就要用动态规划的思想： 

**[贪心算法]：**

分析：先从面额最大的硬币开始尝试，一直往下找，知道硬币总和为N。但是贪心算法不能保证能够找出解（例如，给,2,3,5,然后N=11，导致无解5,5,1）。  

**[动态规划算法]**：

将前面计算的结果保存在数据里，后面重复用的时候直接调用就行，减少重复运算）  

状态转移方程：假设我现在需要的是凑够3元的有几种方案记为F(3)

F(3) =min{F(3-1)+1,F(3-3)+1}

由此可以得到 :F(n)=min(F(n-1)+1,F(n-3)+1,F(n-5)+1)  其中n>{1,3,5}

此时的边界条件是：F(1)=1 F(2)=2 F(0)=0

```java
public class Main{
    static int coins[3] ={1,3,5};
    static int count=11;
    
    public static void main(String args[]){
        int result =new int[count+1];
        
        for(int i=1;i<count;i++){
            int best=Integer,MAX_VALUE;
            for(int j=0;j<coins.length;j++){
                int coin = coins[j];
                if(i - coin <0){
                    break;
                }else if(best >1+result[i-coins]){
                    best = 1+result[i-coin]
                }
            }
            if(best!=Integer.MAX_VALUE){
                result[i] = best;
            }
             
        }
    }
}
    
```

面值1：

- coin=1==1,best=result[1-1]+1=0+1=1=[c1];
- coin=3>1,break;

面值2：

- coin=1<2,best=result[2-1]+1=1+1=2=[c1+c1];
- coin=3>2,break;

面值3：

- coin=1<3,best=result[3-1]+1=2+1=3=[c1+c1+c1];
- coin=3==3,best=result[3-3]+1=1=[c3];
- coin=5>3,break;

面值4：

- coin=1<4, best=result[4-1]+1=1+1=2=[c3+c1]
- coin=3<4, best = result[4-3] +1 =1+1=2=[c1+c3]
- coin=5>4,break

面值5：

- coin=1<5, best=result[5-1]+1=2+1=2=[c3+c1+c1]
- coin=3<5, best = result[5-3] +1 =2+1=3=[c1+c1+c3]
- coin=5==5,best=result[5-5]+1=0+1=1=[c5

**[思想]**：

**[特例的算法]**：此算法可以尽可能的用数目去除以5，然后再用3去取余数，最后的余数就是1的个数

### 凑面额-变形

> 给你六种面额1、5、10、20、50、100元的纸币，假设每种币值的数量都足够多，编写程序求组成N员（N为0-10000的非负整数）的不同组合的个数。  

**[思想]：**

动态规划的三个要素是【最优子结构】、【边界】、【状态转移公式】

首先，我们给纸币面额编号 0、1、2、3、4、5，面额数组`p = {1, 5, 10, 20, 50, 100}`，定义 `f(i, j)` 表示用面额编号为 0、1、…i 的纸币面额，组成 j 元的组合个数。

分析：

- 首先，我们从最大面额 100 开始，1000 元的所有组合中，如果我们不使用面额 100（p[5]），那么问题就变成了用剩下的面额来组合 1000 元，即 `f(4, 1000)`，如果我们使用面额 100（p[5]），那么我们至少使用了一张，问题可以简化为用面额数组表示剩下的 900 元，即 `f(5, 900)`。
- 所以 `f(5, 1000)`的组合个数为 `f(4, 1000)` 与 `f(5, 1000 - p[5])` 的和。
- 因此我们可以得到 **递推公式**： 

```java
f(i, j) =
            f(i-1, j)                   j < p[i] 时
            f(i-1, j) + f(i, j - p[i])  j > p[i]时
            f(i-1, j) + 1               j = p[i]
```

边界条件

```java
f(1, j) = 1, 当 y 大于 0 时 // 任何大于 0 的 j 元钱，都可以用 j 张 1 元来组合
j = 0 时 return 0 // 组成 0 元的组合是不存在的，所以输入 0 元时，我们应该输出 0
```

在从上往下分析完问题后，我们根据初始条件，可以从下往上 **填表格**，表格中的数据为 f(i, j)，即用面额编号为 0、1、…i 的纸币面额，组成 j 元的组合个数。 

| p[i] | i\j  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| 5    | 1    | 0    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 3    |
| 10   | 2    | 0    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 4    |
| 20   | 3    | 0    |      |      |      |      |      |      |      |      |      |      |
| 50   | 4    | 0    |      |      |      |      |      |      |      |      |      |      |
| 100  | 5    | 0    |      |      |      |      |      |      |      |      |      |      |

计算f(1,4),由于j =4<p[i]=5，所以f(1,4) = f(0,4) =1

在计算f(1,5)的时候，根据地推公式，p[1] =5,由于 j=5=p[i]=5所以f(0,5)+1=2

计算f(1,10) j=10>p[1]=5 f(1,10) = f(0,10)+f(1,5)=3;

从以上的分析中可以看出来，因为可以用上一行和前几列的数据，所以我们用一维数组计算，注意因为要用到本行前几列的数据，所有计算顺序是从左往右的

```java
如果N == 0 => return 0;

int [] p= {1,5,10,20,50,100};
int [] a =new int[N+1];

//首先，初始化第0行的数据
j:1->N
  a[j] =1;

i:1  -> 5
  j: 1->N
    如果 j ==p[i] =>a[j]+=1;
	如果 j>p[i] =>a[j]+=a[j-p[i]];

return a[N];

    
}
```

经过观察，我们发现递推中我们没有使用 a[0]，而伪代码的递推关系在计算时（尽管不符合现实意义，0 元钱的组合个数不应该为 1）可以简化为： 

```java
a[0] = 1;
i: 1 -> 5
    j: 1 -> N
        如果 j >= p[i] => a[j] += a[j - p[i]];
```

简化后的源码为：

```java
public long numOfCombine(int N){
    if(N<0) throw new IllegalArgumentException();
    if(N==0) return 0;
    
    int[] p ={1,5,10,20,50,100}
    long[] a =new long[N+1];
    
    for(int j=0;j<=N;j++){
        a[j]=1
    }
    
    for(int i=1;i<5;i++){
        for(int j=1;j<N;j++){
            if(j >=p[i]){
                a[j]+=a[j-p[i]];
            }
        }
    }
}
```

### 非将子序列的长度

**[问题描述]**：

一个序列有N 个数： A[1],A[2],…,A[N] ，求出最长非降子序列的长度。 ( 讲 DP 基本都会讲到的一个问题LIS ： longest increasing subsequence) 

为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。如果我们要求的这N 个数的序列是： 5， 3  ，4， 8， 6 ，7               

根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示）

- 前一个数的LIS长度d(1)=1(序列：5)
- 前2个数的LIS的长度d(2) =1 (序列3,3前面没有比5小的)
- 前3个数的LIS的长度d(3) = 2(序列3,4；4面前有个比它小的3，所以d(3) =d(2)+1
- 前4个数的LIS的长度d(4) =3(序列：3,4,8)；8前面比它小的有三个数，所以d(4)=max{d(1),d(2)+1,d(3)+1 =3}
- 前5个数LIS的长度d(5) = (序列3 4 8)；6前面比它小的数有3个，所以d(5) =max{1，d(2)+1,d(3)+1}
- 前6个数LIS的长度d(6)=4(序列 3 4 6 7)；d(6) =max{1,d(2)+1,d(3)+1,d(5)+1} =4

从上面的流程来看，先求出这个序列中以每个**元素作为结尾**的最大非降子序列的长度，那问题的解总是以序列中某个元素作为结尾的，所以取最大值即可。而且从上面的公式我们很容易看出求d[i]的过程，简单来说，就是从i往前找，如果某个元素A[j] < = A[i]，那么以元素A[j]结尾的最长非降子序列再加上A[i]一定也是一个非降子序列，d[j] + 1肯定是一个非降子序列长度，找到所有符合条件的j，所有符合条件的d[j] + 1的最大值就一定是d[i]的值。从另一个角度去看，因为以A[i]为结尾的最长子序列的倒数第二个元素（假设长度不小于2）肯定是A[i]之前的某一个元素，所有A[j]作为倒数第二个元素的序列就是以A[i]为结尾的子序列。当然，还要考虑特殊的情况，假设A[i]之前没有比其更小的元素，则子序列就是其本身，长度为1。综上所述，状态转移方程如下： 

```
d[i] = max(1, max(d[j] + 1)), 1 <= j < i, A[j] <= A[i];
```

最后问题的解即为：

LIS = max(d[i]); 1 <= i <= n, n为序列的长度

```java
public class LIS {

    public static void main(String[] args) {
        int[] data ={5,3,4,8,6,7};
        int lis = getLIS(data,6);
        System.out.println(lis);
    }

    public static int getLIS(int[] arr, int n) {
        if(arr==null||arr.length<=0) return 0;

        //创建dp数组
        int[] dp=new int[arr.length];
        dp[0]=1;

        for(int i=1;i<arr.length;i++){
            //每次都需要置零
            int maxLength=0;
            for(int j=0;j<i;j++){
                //如果出现比i元素小的，则记录该j对应的dp[j],选取最大的dp[j]
                if(arr[j]<arr[i]){
                    maxLength=Math.max(maxLength, dp[j]);
                }
            }
            dp[i]=maxLength+1;
        }

        int maxResult=0;
        for(int i=0;i<dp.length;i++){
            maxResult=Math.max(maxResult, dp[i]);
        }
        return maxResult;
    }
}
```



## **动态规划的经典模型**

## **线性模型**

线性模型的是动态规划中最常用的模型，上文讲到的钢条切割问题就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。【例题1】是一个经典的面试题，我们将它作为线性模型的敲门砖。

**【例题1】**在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。

**[输入]：** 参数1， 正数数组costs ；参数2， 正数数组profits ；参数3， 正数k； 参数4， 正数m

 costs[i]表示i号项目的花费 

profits[i]表示i号项目在扣除花 费之后还能挣到的钱(利润) 

k表示你不能并行、 只能串行的最多 做k个项目 

m表示你初始的资金 

说明： 你每做完一个项目， 马上获得的收益， 可以支持你去做下 一个 项目。

**[输出]**： 你最后获得的最大钱数。    



### 背包问题

题目描述：

> **假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。** 

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180822/Dci2ikgkj3.png?imageslim)

我们先假设用f[i,j] :表示前i件物品中选中若干放在承载为j的背包找那个，可以取得的最大的价值

p[i]:表示的是物品i的价值

决策：为了使背包中的总价值最大，第i件物品应该放到背包中吗？，分两种情况，第一种是第i件放在背包中，第二种是第i件不放在背包中

f[i,j] = Max(f[i-1,j] ,f[i-1,j-w[i]]+p[i]} 条件是（j>=w[i]）

首先要明确这张表是至底向上，从左到右生成的。

为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了

对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。

同理，c2=0，b2=3,a2=6。

对于承重为8的背包，a8=15,是怎么得出的呢？

根据01背包的状态转换方程，需要考察两个值，

一个是f[i-1,j],对于这个例子来说就是b8的值9，另一个是f[i-1,j-Wi]+Pi；

在这里，

 f[i-1,j]表示我有一个承重为8的背包，当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值

f[i-1,j-Wi]表示我有一个承重为6的背包（等于当前背包承重减去物品a的重量），当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值

f[i-1,j-Wi]就是指单元格b6,值为9，Pi指的是a物品的价值，即6

由于f[i-1,j-Wi]+Pi = 9 + 6 = 15 大于f[i-1,j] = 9，所以物品a应该放入承重为8的背包

**【思路2】：**

现在我们从上到下的来推导：

table[i,j]:表示的是当选序号为前i件的物品中放在承载为j的背包找最大的价值

决策：此时有两种选择，第一种是：选择第i件物品，此时需要的条件是j>w[i] ,此时背包的最大的价值就是如下table[i-1,j-w[i]]+p[i] ，表示的意思就是选第i件物品，然后总的背包大小需要键减第i件物品的大小，而且剩下的选择的物品数要减1

第二种：不选择第i件物品，此时就是从剩下的第i-1件物品中选择最大的价值 table[i-1,j]

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180822/gelifljDJK.png?imageslim)

