# [JVM07]垃圾回收

- 如何判定对象为垃圾对象
  - 引用计数法
  - 可达性分析
- 如何回收
  - 回收策略
    - 标记清除
    - 复制算法
    - 标记-整理算法
    - 分代收集算法
  - 垃圾回收器
    - Serial
    - Parnew
    - Cms
    - G1
- 何时回收



## 一、如何判定对象为垃圾对象

### 1.1 引用计数法

在对象中添加一个引用计数器，当有地方引用它时，计数器的值加1；当引用失效时，计数器的数值减1；任何时刻计数器的值为0的对象就是不可能再使用的对象

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/ji3jB9k2bI.png?imageslim)

`-verbose:gc`：打印的是垃圾回收的信息

`-XX:+PrintGCDetails`:打印的是垃圾回收的详细信息

JDK 8不是采用的是引用计数法

**存在的问题：**

```java
package com.huanghe.test7;

public class GcTest01 {
	
	private GcTest01 instance;
	
	public GcTest01() {
		byte[] m=new byte[20*1024*1024];
	}
	
	public static void main(String[] args) {
		
		GcTest01 test01=new GcTest01();
		
		GcTest01 test02=new GcTest01();
		
		test01.instance=test02;
		
		test02.instance=test01;
		
		test01=null;
		test02=null;
		
		System.gc();			
	}
}
```

​	当对象进行循环引用的时候，不能分析出对象是否是垃圾对象

### 1.2、可达性分析法

通过一系列的GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/kacFC9hbb2.png?imageslim)

可以作为GC Roots的对象包括以下几点:

(3.1)、虚拟机栈（栈帧中的本地变量表）中引用的对象。

(3.2)、方法区中的类静态属性引用的对象或者常量引用的对象。

(3.3)、本地方法栈中JNI（就是native方法）引用的对象。



## 二、垃圾回收算法

### 2.1标记-清除算法(Mark-Sweep)

最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图：

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/G5E8GKkJfA.png?imageslim)

从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。

### 2.2复制算法(Copying)

- 堆内存

  - 新生代
    - Eden 伊甸园（只要创建一个对象就会扔到这里面去）
    - Survivor 存活区
    - Tenured Gen  
  - 老年

  ![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/gBDI9k5Blf.png?imageslim)

  >默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。
  >
  >因为年轻代中的对象基本都是朝生夕死的(80%以上)，**所以在年轻代的垃圾回收算法使用的是复制算法，复制**算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。
  >
  >在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

  ​

  >**一个对象的这一辈子**
  >
  >我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。

  ​

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/mDcidhLbei.png?imageslim)

**原理：**

- 从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存（图中下边的那一块儿内存）上去，之后将原来的那一块儿内存（图中上边的那一块儿内存）全部回收掉

**适用场合：**

- 存活对象较少的情况下比较高效
- 扫描了整个空间一次（标记存活对象并复制移动）
- 适用于年轻代（即新生代）：基本上98%的对象是"朝生夕死"的，存活下来的会很少

**缺点：**

- 需要一块儿空的内存空间
- 需要复制移动对象

**注意：**

- 在该情况下，内存规整，对象的内存分配采用"指针碰撞法"，见《[第二章 JVM内存分配](http://www.cnblogs.com/java-zhao/p/5180492.html)》
- 以空间换时间：通过一块儿空内存的使用，减少了一次扫描

为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/DCL3J2jEel.png?imageslim)



这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。

### 2.3标记-整理算法(Mark-Compact)

结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/lgBI66CCFj.png?imageslim)

**原理：**

- 从根集合节点进行扫描，标记出所有的存活对象，最后扫描整个内存空间并清除没有标记的对象（即死亡对象）（可以发现前边这些就是标记-清除算法的原理），清除完之后，**将所有的存活对象左移到一起**。

**适用场合：**

- **用于年老代（即旧生代）**

**缺点：**

- 需要移动对象，若对象非常多而且标记回收后的内存非常不完整，可能移动这个动作也会耗费一定时间
- 扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）

**优点：**

- 不会产生内存碎片

**注意：**

- 在该情况下，内存规整，对象的内存分配采用"指针碰撞法"，见《[第二章 JVM内存分配](http://www.cnblogs.com/java-zhao/p/5180492.html)》

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/7iiaF9L77j.png?imageslim)

### 2.4分代收集算法(Generational Collection)

分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

目前大部分JVM的GC对于**新生代都采取Copying算法**，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，**当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中，如果出现内存不够就需要内存担保**。

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/20EFhgFCme.png?imageslim)

而老生代因为每次只回收少量对象，因而采用**Mark-Compact算法**。

### 2.5小结

- 年轻代：**复制算法**
- 年老代：**标记-清除或标记-整理**（前者相较于后者会快一些但是会产生内存碎片，后者相较于前者不会产生内存碎片但是由于要移动存活对象所以会慢一些）
- 以上这种年轻代与年老代分别采用不同回收算法的方式称为"分代收集算法"，这也是当下企业使用的一种方式
- 每一种算法都会有很多不同的垃圾回收器去实现，在实际使用中，根据自己的业务特点做出选择就好

## 三、垃圾回收器

### 3.1、Serial/Serial Old

最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，**缺点是需要暂停用户线程。**

### 3.2、ParNew（新生代收集器）

Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集(**主要的关注点是在降低暂停的时间**)

<font color="red">**停顿的时间越短是越有利于用户进行交互的，用户的体验度越好**</font>

### 3.3、Parallel Scavenge

新生代的并行收集器，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个**可控的吞吐量**。

吞吐量：cpu用于运行代码的时间与cpu消耗总时间的比值 

 吞吐量=（执行用户代码的时间）/    (执行用户代码的时间+垃圾回收的时间)

-XX:MaxGCPauseMills 垃圾收集器停顿的时间

-XX:CGTimeRatio   吞吐量的大小

<font color="red">我们又会想如果垃圾收集器停顿的时间不是越小性能就越高吗？</font>

>假如此时的最大停顿时间是100ms，假如此时的最大停顿时间是1ms
>
>那么对应的新生代的内存区域是会发生变化的，内存区域是会变小的；当内存变小之后，回收的频率增大
>
>10s   100ms
>
>5s      70ms

<font color="red">**在后台运算，当用户不是需要特别多的交互的时候，但是为了支持高并发的时候，这么垃圾收集器就派上用场了**</font>

### 3.4. Parallel Old

Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程。

### 3.5. CMS（老年代收集器）

Current Mark Sweep收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用Mark-Sweep算法。

<font color="red">**ParNew是和CMS进行协同工作的,而Parallel Scavenge是不可以的**</font>

​	是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。**对于要求服务器响应速度的应用上**，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。

>区分并行和并发：打一个简单的比喻，比如说扔垃圾和打扫卫生；并行就是作这这实际事情的人都是多个，相互之间是相互不进行影响的，而并发是一边进行扔垃圾，一边进行打扫卫生，两者是同时进行的；

**CMS过程：**

- 初始标记(STW initial mark)

  **初始标记** ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。

- 并发标记(Concurrent marking)

  **并发标记** ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。

- 并发预清理(Concurrent precleaning)

  **并发预清理 **：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。

- 重新标记(STW remark)

  这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"跟对象"开始向下追溯，并处理对象关联。

- 并发清理(Concurrent sweeping)

  清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。

- 并发重置(Concurrent reset)

  这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。

  ![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180412/fFDKCj4hI6.png?imageslim)

**CMS缺点**：

- CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片
- 需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。
- CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。
- 出现Concurrent Mode Failure错误，在并发清理的过程中，在清理的时候新创建的对象就会到新的内存里面去，如果内存过大会出现浪费，但是万一的情况是内存过小就会出现Concurrent Mode Failure错误，出现了这个错误，会触发一个Serial  old收集器进行收集;

 **啥时候用CMS**：

​	如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是硬件牛逼)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(老年代比较大)会更适合使用CMS。



### 3.6. G1

G1(Garbage First)收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。

**G1收集器的历史：**

​	2004年 Sun公司实验室发表了第一篇关于G1的论文

​	2006年集成到了JVM里面去了

​	在JDK7才正式的放到了虚拟机里面

**G1收集器的优势：**

- 并行和并发
- 分代收集
- ​

​	

