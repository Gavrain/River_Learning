# C_指针

内存区的每一个字节都有一个编号这就是地址，如果在程序中定义了一个变量没在对程序进行编译时，系统就会给这个变量分配内存单元。

C语言中对于变量的访问有两种方式，分别是直接访问和间接访问

## 直接访问和间接访问

**直接访问比如 a=5;**

 	系统在编译时，已经对变量分配了地址，例如，若变量a分配的地址是2000，则该语句的作用就是把常数5保存到地址为2000的单元中

**间接访问比如：scanf("%d",&a);**

​	调用函数时，把变量a的地址传递给函数scanf，函数首先把该地址保存到一个单元中，然后把从键盘接收的数据通过所存储的地址保存到a变量中



## 初始指正

在Ｃ语言中，指针是一种特殊的变量，它是存放地址的。假设我们定义了一个指针变量int   *i_pointer

用来存放整型变量 i 的地址。可以通过语句：i_pointer＝＆ｉ；

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180328/7e18FFgm44.png?imageslim)

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180328/cKEBIIKBHG.png?imageslim)



## 初始两个操作符 *和&

*：这个玩意叫做取值操作符

&：这个玩意叫做取址操作符

```c
int i = 2000;
int *pointer;
pointer = &i;
printf("%d\n", *pointer);
```



如果已执行了语句   pointer_１＝＆ａ；

(1)＆* pointer_１的含义是什么？

“＆”和“  * ”两个运算符的优先级别相同，但按**自右而左方向结合**，因此先进行*pointer_１的运算，它就是变量ａ，再执行＆运算。

因此，＆* pointer_１与＆ａ相同，即变量a的地址

如果有： pointer_2 ＝＆* pointer_１；

它的作用是将`＆ａ`（ａ的地址）赋给pointer_2 ，如果pointer_2 原来指向ｂ，经过重新赋值后它已不再指向ｂ了，而指向了ａ



(2) *＆ａ的含义是什么？

```c
先进行＆ａ运算，得ａ的地址，再进行*运算。即＆ａ所指向的变量，也就是变量a

 * ＆ａ和*pointer_１的作用是一样的，它们都等价于变量ａ。即*＆ａ与ａ等价。
```



(3) （*pointer_１）＋＋相当于ａ＋＋。

注意括号是必要的，如果没有括号，就成为了*pointer_１＋＋，从附录可知：++和 * 为同一优先级别，而结合方向为自右而左，因此它相当于*(pointer_１＋＋)。

n由于++在pointer_1的右侧，是“后加”，因此先对pointer_１的原值进行*运算，得到ａ的值，然后使pointer_１的值改变，这样pointer_１不再指向ａ了。





## 指针和指针变量

 知道了一个变量的地址，就可以通过这个地址来访问这个变量，因此，又把变量的地址称为该**变量的“指针”**

C语言中可以定义一类特殊的变量，这些变量专门用来存放变量的地址，称为**指针变量**

> 注意指针变量中存放的值是地址（即指针）。注意区分指针和指针变量





## 定义一个指针变量

float *pointer_3   / /  pointer__3是指向float型变量的指针变量

可以用赋值语句使一个指针变量指向另外一个变量的地址，从而使它指向该变量

>指针变量前面的“*”,表示该变量的类型为指针型变量。其一般的形式为：
>
>类型说明符    *变量名
>
>类型说明符表示本指针变量 **所指向的变量**的数据类型



需要特别注意的是，只有整型变量的地址才能放到指向整型变量的指针变量中。下面的赋值是错误的∶

```c
        float a; 

        int * pointer_1; 

        pointer_1=&a;          

 /*将float型变量的地址放到指向整型变量的指针变量中，错误 */
```

  



