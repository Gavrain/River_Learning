# 对接支付宝

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180826/lfmAihA9LC.png?imageslim)

订单表：订单号，订单状态，订单金额，支付金额，商品编号，购买的数量，创建时间，付款时间

流水表：流水号，订单号，商品id,付款金额，付款方式，购买数量

![mark](http://ozxf77u6w.bkt.clouddn.com/blog/180826/kdiA3iK38d.png?imageslim)



## 用户重复提交的问题

1：AjAx分段提交的方式进行防止重复提交，不断的刷新页面的问题

第一段：保存订单：这个时候会创建订单的信息，其中包括订单号

第二段：根据成功的状态，把当前的URL进行一个跳转。跳转到一个去支付的页面



2：form的token来做

Java 使用Token令牌防止表单重复提交的步骤：

  - 在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。 

  - 将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端。

  - 在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，

  - 如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。

**在下列情况下，服务器程序将拒绝处理用户提交的表单请求：**

  - 存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。  - 当前用户的Session中不存在Token(令牌)。 

# 创建订单的幂等的一点思考

如果一个用户分两次下单，购买的商品都是一样的。

第一次请求：user1：购买一个商品product1； 
第二次请求：user1：还是购买一个商品product1；

这种场景也很常见，是需要生成两个订单的。这样子看起来貌似创建订单的接口做不了幂等，因为业务数据一样的情况下，还是需要生成多个订单。但是这样子设计还是有个坑，万一创建订单的接口超时了呢？并且调用方进行了重试的话，那就可能变成用户其实想下一个单，但是订单系统其实生成了多个订单。比如说： 

> 调用方发起创建订单的请求，订单系统收到了，并成功创建订单了。但是由于系统原因或者网络原因等，没有及时告知调用方订单已经创建成功，调用方一直等待回复，直到超时了。调用方再次发起了创建订单的请求，这个时候就可能会生成多个订单。 

如果订单接口不支持幂等的情况下，如何应付这种情况呢？有两种方法 

第一种:

> 当调用方调用订单接口超时了，是会收到异常的，这个时候调用方捕获到这个异常后，`不要进行重试操作了，调用订单的一个回滚接口，将订单取消掉。`虽然看起来很low，但是还是有人这么做的。

第二种：

> 让订单系统提供一个订单是否创建成功的查询接口，根据一些关键业务字段去查询，如果查询到已经创建成功了，则调用方不要重试了。

上面两种方案都有人用过，但是都没实现幂等。其实针对上面的场景，用幂等来设计也不是很难。可以使用一个唯一的流水号ID，用来标识是不是同一个请求或者交易。这种ID通常都需要具备`全局唯一性`。假设让客户端来生成这个ID，每个创建订单的请求生成一个唯一的ID。那么订单系统如何根据来实现幂等呢？通常有两种。 

第一种：

> 先将这个ID保存到一个流水表里面，并且流水表中将这个ID设置为`UNIQUE KEY`,如果插入出现冲突了，则说明这个创建订单的请求已经处理过了，直接返回之前的操作结果。

第二种：

> 根据ID读取流水表，如果没有读取到，则创建订单和插入流水表。如果读取到了，则返回之前的操作结果。

不建议使用第二种方式，因为大部分情况下的请求都不是重试来的，让100%的请求都要去读取流水表，实在是不应该。另外，读取流水表的操作也是有潜在风险的，因为用数据库的读检查来确保数据存在性可能因为竞争而不生效，存在竞态条件。

建议用第一种方案，因为本来流水表就是要插入，顺便利用`UNIQUE KEY`的冲突特性来判断。

现在我们用第一种方案完整描述一下整个处理过程。

> 当调用方携带流水号ID调用创建订单的接口，如果出现超时了，调用方不知道订单到底创建成功还是失败，这个时候，用`同一个`流水号进行重试，订单系统虽然收到了两个请求，但是由于流水号ID是同一个，可以根据流水表来做幂等操作。并告知对方订单创建成功与否。

`